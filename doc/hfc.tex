\section{HFC Rdf-Datenbank}

Die Queries, die an die Datenbank stellen kann haben folgende Syntax (EBNF):
\begin{table}[h]
  \centering\small
\begin{verbatim}
<query>     ::= <select> <where> [<filter>] [<aggregate>] | ASK <groundtuple>
<select>    ::= {"SELECT" | "SELECTALL"} ["DISTINCT"] {"*" | <var>^+}
<var>       ::= "?"{a-zA-Z0-9}^+ | "?_"
<nwchar>    ::= any NON-whitespace character
<where>     ::= "WHERE" <tuple> {"&" <tuple>}^*
<tuple>     ::= <literal>^+
<gtuple>    ::= <constant>^+
<literal>   ::= <var> | <constant>
<constant>  ::= <uri> | <atom>
<uri>       ::= "<" <nwchar>^+ ">"
<atom>      ::= "\""  <char>^* "\"" [ "@" <langtag> | "^^" <xsdtype> ]
<char>      ::= any character, incl. whitespaces, numbers, even '\"'
<langtag>   ::= "de" | "en" | ...
<xsdtype>   ::= "<xsd:int>" | "<xsd:long>" | "<xsd:float>" | "<xsd:double>" |
                "<xsd:dateTime>" | "<xsd:string>" | "<xsd:boolean>" | "<xsd:date>" |
                "<xsd:gYear>" | "<xsd:gMonthDay>" | "<xsd:gDay>" | "<xsd:gMonth>" |
                "<xsd:gYearMonth>" | "<xsd:duration>" | "<xsd:anyURI>" | ...
<filter>    ::= "FILTER" <constr> {"&" <constr>}^*
<constr>    ::= <ineq> | <predcall>
<ineq>      ::= <var> "!=" <literal>
<predcall>  ::= <predicate> <literal>^*
<predicate> ::= <nwchar>^+
<aggregate> ::= "AGGREGATE" <funcall> {"&" <funcall>}^*
<funcall>   ::= <var>^+ "=" <function> <literal>^*
<function>  ::= <nwchar>^+
\end{verbatim}
  \caption{BNF der Datenbank-Querysprache}
  \label{tab:hfcquerybnf}
\end{table}

\paragraph{Anmerkungen}

Die reservierten Symbole \texttt{ASK}, \texttt{SELECT}, \texttt{SELECTALL},
\texttt{DISTINCT}, \texttt{WHERE}, \texttt{FILTER}, und \texttt{AGGREGATE}
müssen \emph{nicht} in Großbuchstaben sein.

Weder \texttt{filter} Prädikate noch \texttt{aggregate} Funktionen dürfen
reservierte Symbole als Namen tragen.

\emph{don't-care} Variablen sollten \emph{explizit} markiert sein, indem
\verb|?_| benutzt wird, vor allem, wenn \texttt{SELECT} mit \verb|*| benutzt
wird, z.B. in:
\begin{verbatim}
     SELECT DISTINCT * WHERE ?s <rdf:type> ?_
     SELECT * WHERE ?s <rdf:type> ?o ?_ ?_
\end{verbatim}
Um z.B. die Object Position zu beschränken ohne sie zu projizieren können
don't-care Variablen benutzt werden:
\begin{verbatim}
     SELECT ?s WHERE ?s <rdf:type> ?o ?_ ?_ FILTER ?o != <foo-class>
\end{verbatim}

Aggregate in HFC nehmen ganze Tabellen oder Teile davon und berechnen aus allen
Einträgen ein Resultat. Weil der Typ von Aggregaten und Filter-Funktionen nicht
überladen werden kann, gibt es einige ähnliche Funktionen für verschiedene
Typen, z.B. F für \texttt{float}, L für \texttt{long}, D für \texttt{double}, I
für \texttt{int}, S für \texttt{String}.

\begin{table}[h]
  \centering
 \begin{tabular}{lll}
   CountDistinct&  FSum&             LMax\\
   Count&          FMean&            LMean\\
   DMean&          LGetFirst2&       LMin\\
   DSum&           LGetLatest2&      LSum\\
   DTMax&          LGetLatest&       LGetLatestValues\\
   DTMin&          LGetTimestamped2& Identity     \\
 \end{tabular}
  \caption{Verfügbare Aggregate}
  \label{tab:hfcaggregates}
\end{table}

Außer \verb|==| und \verb|!=| können in den \texttt{filter} Ausdrücken
auch funktionale Operatoren benutzt werden. Auch hier gibt es viele
Versionen der gleichen Funktion für unterschiedliche Datentypen.

\begin{table}[h]
  \centering\small
\begin{tabular}{llll}
CardinalityNotEqual &        FNotEqual &               IntStringToBoolean &      LMin \\
Concatenate &                FProduct &                IProduct &                LNotEqual \\
DTIntersectionNotEmpty &     FQuotient &               IQuotient &               LProduct \\
DTLessEqual &                FSum &                    IsAtom &                  LQuotient \\
DTLess &                     GetDateTime &             IsBlankNode &             LSum \\
DTMax2 &                     GetLongTime &             IsNotSubtypeOf &          LValidInBetween\\
DTMin2 &                     HasLanguageTag &          ISum &                    MakeBlankNode \\
EquivalentClassAction &      IDecrement &              IsUri &                   MakeUri \\
EquivalentClassTest &        IDifference &             LDecrement &              NoSubClassOf \\
EquivalentPropertyAction &   IEqual &                  LDifference &             NoValue \\
EquivalentPropertyTest &     IGreaterEqual &           LEqual &                  PrintContent \\
FDecrement &                 IGreater &                LGreaterEqual &           PrintFalse \\
FDifference &                IIncrement &              LGreater &                PrintSize \\
FEqual &                     IIntersectionNotEmpty &   LIncrement &              PrintTrue \\
FGreaterEqual &              ILessEqual &              LIntersectionNotEmpty &   SameAsAction \\
FGreater &                   ILess &                   LIsValid &                SameAsTest \\
FIncrement &                 IMax2 &                   LLessEqual &              SContains.java\\
FLessEqual &                 IMax &                    LLess &                   UDTLess \\
FLess &                      IMin2 &                   LMax2 \\
FMax &                       IMin &                    LMax \\
FMin &                       INotEqual &               LMin2 \\
\end{tabular}
\caption{Verfügbare Filter-Funktionen}
  \label{tab:hfcfunctions}
\end{table}
