\section{Rudimant-Kompiler und Laufzeitsystem}

Der Rudimant-Kompiler übersetzt Regeldateien mit Extension \texttt{.rudi} in
Java-Dateien. Dazu braucht er eine Ontologie, in der die RDF Klassen und
Prädikate, die im \texttt{.rudi}-Code verwandt werden, spezifiziert sind.

Im Fall des POC liegen die Quelldateien in \texttt{src/main/rudi} und die
dazugehörende Ontologie in \texttt{src/main/resources/ontology}. Damit HFC
die Ontologie benutzen kann, muss sie im ntriples-Format vorliegen. Die
derzeitige Ontologie wird mit Protégé erstellt und aus dem OWL-XML Format
mit Hilfe des \texttt{rapper}-Tools in eine \texttt{.nt} ntriples Datei
übersetzt. \texttt{rapper} ist Teil des Ubuntu-Package \texttt{raptor2-utils},
das Script \texttt{ntcreate} im \texttt{poc} Verzeichnis updated alle nicht
aktuellen \texttt{.nt} Files aus den \texttt{.owl} Versionen.

Weitere settings, die für die Kompilation wichtig sind, finden sich in der
Datei \texttt{herbea.yml}, die von \texttt{compile} Skript benutzt wird. Auch
hier sind alle relativen Pfade relativ zum Verzeichnis, in dem die
\texttt{.yml} Datei liegt.

Für standalone Mockup-Tests kann der POC auch isoliert mit dem \texttt{run.sh}
script gestartet werden, die ``Sensordaten'' werden dann nach und nach in
der main-Methode eingespielt.

Der folgende Text ist leider unvollständig und muss noch ergänzt werden. Für
die meisten Konstrukte gibt es einige Beispiele in den \texttt{rudi}
Quelldateien.

\subsection{Rudimant Regeln}

%{\Huge TODO: testen, ob alle Beispiele so funktionieren, wie sie sollen !!!!!!}

\subsubsection{''Globale'' Funktionen und Variablen} \label{rudimant-global}

Für Funktionen, die nicht oder nur umständlich in rudi-Code implementiert werden können, sollte der Nutzer eine Javaklasse MyAgent von der abstrakten Klasse Agent ableiten. Funktionen und Variablen, die in dieser Klasse deklariert wurden und später im rudi-Code benutzt werden sollen, müssen mit vollständiger Typangabe in einer Datei MyAgent.rudi registriert werden, sodass die Typinferenz von rudimant sie korrekt berücksichtigen kann (zur Syntax siehe \ref{rudimant-Typinferenz}).\\
Die Klasse MyAgent mitsamt Packagenamen muss in der config.yml Datei eines Projektes unter dem Eintrag ''wrapperClass'' spezifiziert werden, um im Compile-Schritt einen Effekt zu zeigen. Rudimant nutzt die Klasse MyAgent dann als Superklasse der im Compile-Schritt angegebenen Datei im rudi-Format und verlinkt Funktionsaufrufe und Variablennutzungen in allen untergeordneten rudi-Dateien auf diese, sodass korrekte Aufrufe im resultierenden Java-Code gewährleistet sind.

\subsubsection{RDF Zugriff, funktionale vs. relationale Prädikate
  \texttt{+=}, \texttt{-=}}

\begin{minipage}{0.4\textwidth}
\begin{verbatim}
Child c;
String name = c.name;
c.name = "new name";
\end{verbatim}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{verbatim}
String name = (String)c.getValue("<upper:name>");
c.setValue("<upper:name>", "new name");
\end{verbatim}
\end{minipage}
\newline
Durch die Verbindung zu hfc während des Compile-Vorganges hat rudimant vollen Zugriff auf die Datenbank und kann nicht nur Rdf-Objekte anhand ihrer Typen erkennen, sondern auch erkennen, wann ein Feldzugriff auf ein Rdf-Objekt erfolgt und ihn in solchen Fällen in einen Zugriff auf die Datenbank umwandeln. Dies ist sowohl für Zugriffe auf Properties als auch für Änderungen ihres Inhalts möglich und lässt sich, sofern dies in der verwendeten Ontologie möglich ist, beliebig oft hintereinander ausführen.\\

TODO: funktional vs relational?

Die beiden Operatoren \texttt{+=} und \texttt{-=} sind in rudimant überladen. Sie können sowohl wie in Java zum Rechnen mit Integer, float und double verwendet werden, als auch im Zusammenspiel mit Sets und Listen. $ a += b $ wird hierbei in $ a.add(b) $ umgewandelt, $ a-= b $ resultiert in $ a.remove(b) $.
  
\subsubsection{Regeln und Labels}

\begin{verbatim}
introduction:
  if (introduction){
    if (user.unknown){
      ask_for_name:
        if (talkative) {
          askForName();
        }
    } else {
      greetUser();
    }
  }
\end{verbatim}

Das Kernstück von rudimant sind die Dialogregeln. Eine Regel beginnt mit ihrem Namen, einem möglichst aussagekräftigen Label, gefolgt von einem Doppelpunkt. Anschließend folgt ein if-statement. Die Clause des Statements drückt die Bedingung aus, unter der die Regel ausgeführt werden soll, im Body steht der auszuführende Code.\\
Aussagekräftige Labels sind zum Debugging wichtig. Der generierte Code kann zur Laufzeit debuggt werden, indem man in Agent den Flag ... setzt. Der Output des Loggers wird dann das Label jeder Regel, die evaluiert wird, zusammen mit der Auswertung der Bedingung angeben.\\
% Bsp debugging-output
Regeln können beliebig tief geschachtelt werden, d.h., jede Regel kann wiederum Subregeln in ihrem Body haben.

%\subsubsection{Propose}

\subsubsection{Struktur einer Datei im rudi-Format}

Anders als Java stellt rudimant nicht den Anspruch, dass die Einträge in einer Datei in irgendeine Form von übergeordneter Struktur gefasst werden. Die Regeln können ebenso wie Funktionsdeklarationen direkt in die Datei geschrieben werden. Dasselbe gilt für jede Art valider (Java-) Statements, wie etwa Zuweisungen, for-Schleifen usw.. Rudimant wird bei der Kompilation eine Java-Klasse erstellen, in die es die Funktionen sowie die Regeln, zu Funktionen transformiert, einträgt. Alle weiteren Statements werden in der korrekten Reihenfolge in die erzeugte Methode process() verschoben, wobei generierte Aufrufe an die Regelfunktionen zwischen ihnen gewährleisten, dass die Regeln und Statements in der Reihenfolge ausgeführt werden, die im rudi-Code spezifiziert war. Dies ermöglicht also, nicht in Regeln gefasste Abbruchbedingungen einzubauen, unter denen die Ausführung der ganzen Datei - und möglicher importierter Dateien - sofort beendet werden soll.\\
Datei-global deklarierte Variablen werden als Klassenvariablen angelegt.

\subsubsection{Dialogakte und Hütchen} \ {\Large\verb|^|}

\begin{verbatim}
emitDA(#Inform(Answer, what=^solution));
\end{verbatim}

\subsubsection{Typinferenz} \label{rudimant-Typinferenz}

Rudimant erlaubt statische Typzuweisungen sowie Casting, beides ist jedoch nicht zwingend notwendig.\\
Ist beispielsweise der Typ der rechten Seite einer Variablendeklaration mit Zuweisung bekannt oder inferierbar, so ist es nicht notwendig, den Typ der Variablen explizit anzugeben.\\
Als zeitsparendes Feature bietet rudimant insbesondere das automatische Vervollständingen von bool'schen Ausdrücken in den Clauses von if, while und for an. Da in diesem Fall bekannt ist, dass das Ergebnis boolean sein muss, ergänzt rudimant automatisch den Test auf die Existenz eines Objektes in der Clause, sollte dieses nicht Typ boolean sein. Bei Feldzugriffen testet es für jeden Teilzugriff, dass das erhaltene Objekt nicht null ist, um einer NullPointerException zur Laufzeit des generierten Codes vorzubeugen.

\textbf{Rudimant Typinformationen zur Verfügung stellen}\\
In manchen Fällen, wie etwa der Benutzung von außerhalb der rudi-Dateien deklarierten Funktionen und Variablen, ist es notwendig, rudimant Informationen über Typen zu geben. Dabei gilt folgendes Schema, nach dem Typen an beliebiger Stelle, für gewöhnlich jedoch in der Datei MyAgent.rudi (siehe \ref{rudimant-global}) deklariert werden können:\\
\begin{tabular}{ll}
$<myType> someVariable;$ &  es gibt die Variable myVariable vom Typ $<myType>$;
						 !! dies wird nicht in den kompilierten Code übernommen, ist also keine Variablendeklaration im Java-Sinne !! \\
$<myType> someFunction(<typeA> a, <typeB> b);$ &  Funktion someFunction nimmt Argumente vom Typ $<typeA>$ und $<typeB>$ und gibt ein Objekt vom Typ $<myType>$ zurück (void = void) \\
$[<type>]. <myType> Function(<typeA> a);$ & siehe oben; die Funktion muss auf einem Objekt der Klasse $<type>$ aufgerufen werden. Generics erlaubt.
\end{tabular}

\subsubsection{Überladene Vergleichsoperatoren und Tests}

\begin{minipage}{0.4\textwidth}
\begin{verbatim}
if (speechAct <= #Question){
  ...
}
\end{verbatim}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{verbatim}
if (isSmallerEqual(speechAct, new DialogueAct("Question")) {
  ...
}
\end{verbatim}
\end{minipage}
\newline
Die Vergleichsoperatoren in rudimant sind überladen. Neben den aus Java bekannten Anwendungen als Vergleichsoperatoren können sie auch auf Dialogakte angewendet werden. In diesen Fällen werden sie zu Subsumptionsoperatoren.

\begin{minipage}{0.4\textwidth}
\begin{verbatim}
if (! c.user.personality.nonchalance){
  ...
}
\end{verbatim}
\end{minipage}
\begin{minipage}{0.6\textwidth}
\begin{verbatim}
if (!((((c != null) && (c.user != null))
      && (c.user.personality != null))
      && (c.user.personality.nonchalance != null))) {
  ...
}
\end{verbatim}
\end{minipage}

Dies überschneidet sich mit dem Doku-Teil zur Typinferenz; wohin damit?

\subsubsection{Funktionale Konstrukte (lambda)}
\begin{verbatim}
boolean contains(Collection coll, Predicate pred);
boolean all(Collection coll, Predicate pred);
List<Object> filter(Collection coll, Predicate pred);
List<Object> sort(Collection coll, Comparator c);
\end{verbatim}

\subsubsection{\texttt{import}}

%\begin{itemize}
%\item ``Globale'' Funktionen und Variablen
%\item RDF Zugriff, funktionale vs. relationale Prädikate
%  \texttt{+=}, \texttt{-=}
%\item Regeln und Labels
%%\item \texttt{propose}
%\item Dialogakte und\ {\Large\verb|^|}
%\item Typinferenz
%\item Überladene Vergleichsoperatoren und Tests
%\item Funktionale Konstrukte (lambda)
%\item \texttt{import}
%\end{itemize}

\subsection{Struktur des POC Rudimant-Projekts}

TODO: Siehe Bild für Softprak, Beschreibung von HerbeaAgent.rudi
vs. HerbeaAgent.java und Rolle von HerbeaClient

Die Basisklassen von Herbea sind \texttt{HerbeaClient}, der die Kommunikation
mit der Außenwelt herstellt, und \texttt{HerbeaAgent}, der Java-Funktionalität
zur Verfügung stellt, die sich nicht ohne weiteres in \texttt{rudi} Dateien
implementieren lässt (komplexe Queries an die Datenbank, etc.).

Zu \texttt{HerbeaAgent.java} gehört noch eine Datei \texttt{HerbeaAgent.rudi},
die sozusagen das Interface beschreibt, auf das der \texttt{rudi} Quellcode
zugreifen kann. Hier können auch statt der generischen Klasse \texttt{Rdf} die
Klassen aus der Ontologie spezifiziert werden, wenn diese genauer angegeben
werden können. Das hilft dem Kompiler bei der Typinferenz und dem richtigen
Zugriff mit RDF-Prädikaten.

\subsection{Default-Funktionalität im Laufzeitsystem}
Alles was in \texttt{Agent} bereitgestellt wird. Die aktuelle Liste der
bereitgestellten Funktionen finden sich in \texttt{rudimant} unter
\texttt{src/main/resources/Agent.rudi}.

\begin{itemize}
\item timeouts
\begin{verbatim}
void newTimeout(String name, int millis);
boolean isTimedOut(String name);
void removeTimeout(String name);
boolean hasActiveTimeout(String name);
\end{verbatim}
\item Senden von Dialogakten an die Generierung
\begin{verbatim}
DialogueAct emitDA(int delay, DialogueAct da);
DialogueAct emitDA(DialogueAct da);
\end{verbatim}
\item Zugriff auf DialogAkte aus der Session
\begin{verbatim}
// my last outgoing resp. the last incoming dialogue act
DialogueAct myLastDA();
DialogueAct lastDA();

// did i say something like ta in this session (subsumption)? If so, how many
// utterances back was it? (otherwise, -1 is returned)
int saidInSession(DialogueAct da);
// like saidInSession, only for incoming dialogue acts
int receivedInSession(DialogueAct da);

boolean waitingForResponse();
void lastDAprocessed();
\end{verbatim}
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "master"
%%% End:
