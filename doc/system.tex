\newcommand{\caret}{{\large\textbf{\textasciicircum}}}

\section{The \vonda Compiler}

The compiler turns the \vonda source code into Java source code using the
information in the ontology. Every source file becomes a Java class. The
generated code will not serve as an example of good programming practice, but a
lot of care has been taken in making it still readable and debuggable. The
compile process is separated into three stages: parsing and abstract syntax
tree building, type checking and inference, and code generation.

The \vonda compiler's internal knowledge about the program structure and the
RDF hierarchy takes care of transforming the RDF field accesses to reads from
and writes to the database. Beyond that, the type system, resolving the exact
Java, RDF or RDF collection type of arbitrary long field accesses,
automatically performs the necessary casts for the ontology accesses.

\subsection{\vonda's Architecture}

Figure~\ref{fig:architecture} shows the architecture of a runnable \vonda project.

\begin{figure}[htbp]
  \centering
  \input{vonda-framework}
  \caption{Schematic of a \vonda interaction manager implementation}
  \label{fig:architecture}
\end{figure}

A \vonda project consists of an ontology, a custom extension of the abstract
\texttt{Agent} class (the so-called \emph{wrapper class}), a client interface
to connect the communication channels of the application to the agent, and a
set of rule files that are arranged in a tree, using \texttt{import}
statements. The blue core in Figure~\ref{fig:architecture} is the run-time system that
is part of \vonda, while all light grey elements are the application specific parts
of the agent. A \texttt{Yaml} project file contains all necessary information
for compilation: the ontology, the wrapper class, the top-level rule file and
other parameters, like custom compile commands for \vonda's debugger.

The \vonda compiler translates rule files with the extension \texttt{.rudi} to
Java files. During this process, the ontology storing the RDF classes and
properties is used to automatically infer types, resolve whether field accesses
are actually accesses to the database, etc (see section
\ref{sec:typeinference}).
Every rule file can define variables and functions in \vonda syntax which are
then available to all imported files.

The current structure assumes that most of the Java functionality that is used
inside the rule files will be provided by the \texttt{Agent} superclass. There are,
however, alternative ways to use other Java classes directly (see section \ref{sec:javatypes} for further info).
The methods and fields from the custom wrapper class can be made available to
all rule files by declaring them in the interface connecting the \texttt{.rudi}
code to the Java framework. This interface must have the same name as the
wrapper class but end with \texttt{.rudi} (in the example of figure
~\ref{fig:architecture}, this would be \texttt{MyAgent.rudi}).

\subsection{The \vonda Rule Language}
\label{sec:language}

\vonda's rule language looks very similar to Java/C++. There are a number of
specific features which make it much more convenient for the specification of
dialogue strageties. One of the most important features is the way objects in
the RDF store can be used throughout the code: RDF objects and classes can be
treated similarly to those of object oriented programming languages, including
the type inference and inheritance that comes with type hierarchies.

\subsubsection{The Structure of a \vonda File}

\vonda does not require to group statements in some kind of high-level
structure like e.g. a class. It is, in fact, not possible to define classes in
\texttt{.rudi} files at all, rules and method declarations have to be put
directly into the rule file. The same holds for every kind of valid
(Java-) statement, like assignments, \texttt{for} loops etc. From this, the
compiler will create a Java class where the methods and rules that are
transformed are represented as methods of this specific (generated)
class. All other statements as well as auto-generated calls to the methods
representing the rules will be put into the \texttt{process()} method that
\vonda creates to build a rule evaluation cycle. In doing so, the execution
order of all statements, including the rules, is preserved.

This functionality offers possibilities to e.g. define and process high-level
variables that you might want to have access to in subsequent rules or to insert
termination conditions that prevent some rule executions.

\textbf{Warning:} It is important to know that variables declared globally
in a file will be transformed to fields of the Java class. We found that in
very rare occasions, this can lead to unexpected behaviour when using them in a
propose or timeout block as well as changing them in a global statement. As
proposes and timeouts will not immediately be executed, they need every
variable used inside them to be effectively final. \vonda leaves the evaluation
of validness of variables for such blocks to Java. We found that Java might
mistakenly accept variables that are not effectively final, what might lead to
completely unexpected behaviour when proposes and timeouts with changed
variable values are executed.

The only important exeption, where globally defined variables persist throughout
the whole runtime of the system are variables defined in the top-level rule
file. This is on purpose, and can be used to define persistent
variables also usable in lower-level rule files.

\subsubsection{RDF accesses and functional vs. relational properties}
\label{sec:rdfaccesses}

\begin{figure}[htb]
\begin{minipage}{0.5\columnwidth}
\small%
\begin{lstlisting}
user = new Animate;
user.name = "Joe";
set_age:
if (user.age <= 0) {
  user.age = 15;
}
\end{lstlisting}
\end{minipage}\ \vrule\hspace{1ex}
\begin{minipage}{0.44\columnwidth}
    \small\begin{tikzpicture}[
  blob/.style={circle, fill=yellow!50!white, minimum width=2mm},
  txt/.style={node distance=3mm}]
  \draw (0,0) node (agent) [blob]{};
  % BEWARE: RIGHT OF= IS DEPRECATED, DON'T USE IT
  \node (agtxt) [right= 0.1 of agent, txt] {Agent};
  \node (name) [below= 0.4 of agtxt.west, anchor=west]{\emph{name}: \texttt{xsd:string}};
  \node (animate) [blob, below=0.7 of agtxt.west]{};
  \node (antxt) [right= 0.1 of animate, txt] {Animate};
  \node (name) [below= 0.4 of antxt.west, anchor=west]{\emph{age}: \texttt{xsd:int}};
  \node (inanimate) [blob, below= 0.5 of animate, node distance=9mm]{};
  \node (intxt) [right= 0.1 of inanimate, txt] {Inanimate};
  \draw (agent) |- (animate);
  \draw (agent) |- (inanimate);
\end{tikzpicture}
\end{minipage}
  \caption{Ontology and \vonda code}
  \label{fig:rdfobjects}
\end{figure}

Figure \ref{fig:rdfobjects} shows an example of \vonda code, and how it relates
to RDF type and property specifications, schematically presented on the right.  The
domain and range definitions of properties are picked up by the compiler and then
used in various places, e.g., to infer types, do automatic code or data
conversions, or create ``intelligent'' boolean tests, like in line 4, which
will expand into two tests, one testing for the existence of the property for
the object, and in case that succeeeds, a test if the value is smaller or equal than
zero. If there is a chain of more than one field/property access, every part is
tested for existence in the target code, keeping the source code as concise as
possible. Also for reasons of brevity, the type of a new variable needs not be
given if it can be inferred from the value assigned to it.

New RDF objects can be created with \texttt{new}, similar to Java objects; they
are immediately reflected in the database, as are all changes to already
existing objects.

\begin{table}[htbp]
  \centering\small
\begin{minipage}[t]{0.355\textwidth}
\begin{lstlisting}
c = new Child;
String name = c.name;
c.name = "new name";
Set middle = c.middleNames;
c.middleNames += "John";
c.middleNames -= "James";
c.name = null;
\end{lstlisting}
\end{minipage}\\{\Large$\Downarrow$}\\
\begin{minipage}[t]{0.8\textwidth}
\begin{lstlisting}
String name = (String)c.getValue("<upper:name>");
c.setValue("<upper:name>", "new name");
Set middle = (Set<Object>)c.getValue("<upper:middleNames");
c.add("<upper:middleNames", "John");
c.remove("<upper:middleNames", "James");
c.clearValue("<dom:name>");
\end{lstlisting}
\end{minipage}
  \caption{Examples for an RDF property access}
  \label{tab:property-access}
\end{table}
\todo[inline]{missing creation of child in lower part, plus "Set middle" is no
  proper code, line numbers used in text, but not present in figure}

The connection of \vonda to the ontology loaded into HFC during compile time
enables the compiler to recognize the correct RDF class to create a new
instance when encountering \texttt{new}, and to resolve field/property
accessses to all RDF instances. Field accesses as shown in line 2 and 3 of
table \ref{tab:property-access} will be analyzed and transformed into database
accessses. \vonda will also draw type information from the database. If the
name property of the RDF class \texttt{Child} is of type \texttt{String},
exchanging line 2 by the line \texttt{int name = c.name} will result in a
warning of the compiler. During this process, the compiler will automatically
also use the correspondence of XSD and Java types shown in table
\ref{fig:RdfToJava}.

\begin{table}[htb]
{\small\ttfamily\begin{center}
\begin{tabular}{ll@{\hspace{8em}}ll}
<xsd:int> & Integer & <xsd:integer> & Long\\
<xsd:string> & String & <xsd:byte> & Byte\\
<xsd:boolean> & Boolean & <xsd:short> & Short\\
<xsd:double> & Double & <xsd:dateTime> & Date\\
<xsd:float> & Float & <xsd:date> & XsdDate\\
<xsd:long> & Long & <xsd:dateTimeStamp> & Long
\end{tabular}\end{center}}\vspace{-2ex}
\caption{\label{fig:RdfToJava}Standard RDF types and the Java types as which they will be recognized}
\end{table}

Moreover, \vonda determines whether an access is made using functional or
relational predicates and will handle it accordingly, assuming a collection
type if necessary. In the rule language, the operators \texttt{+=} and
\texttt{-=} are overloaded. They can be used with sets and lists as shortcuts
for adding and deleting objects. \texttt{a += b} will be compiled to
\texttt{a.add(b)} and \texttt{a -= b} results in \texttt{a.remove(b)}, as shown
in table~\ref{tab:property-access}.

\subsubsection{Rules and rule labels}

The core of \vonda dialogue management are the dialogue rules, which will be
evaluated at run-time system on every trigger generated from the environment or
the internal processing.
A rule (optionally) starts with a name that is given as a Java-like label: an
identifier followed by a colon. Following this label is an
\texttt{if}-statement, with optional \texttt{else} case. The clause of the
\texttt{if}-statement expresses the condition under which the rule, or rather
the \texttt{if} block, is to be executed; in the \texttt{else} block you can
define what should happen if the condition is \texttt{false}, like stopping the
evaluation of (a sub-tree of) the rules if necessary information is missing.

\begin{figure}[htb]
\begin{small}
\begin{lstlisting}
introduction:
  if (introduction) {
    if (user.unknown) {
      ask_for_name:
        if (talkative) askForName();
    } else
      greetUser();
  }
\end{lstlisting}
\end{small}
\caption{A simple rule}
\end{figure}

Rules can be nested to arbitrary depth, so \texttt{if}-statements inside a rule
body can also be labelled. The labels are a valuable tool for debugging the
system at run-time, as they can be logged live with the debugger GUI
(cf. chapter \ref{sec:debugger}). The debugger can show you which rules were
executed when and what the individual results of each base clause of the
conditions were.

\subsubsection{The \texttt{propose} and \texttt{timeout} constructs}

There are two statements with a special syntax and semantics: \texttt{propose}
and \texttt{timeout}. \texttt{propose} is \vonda's current way of implementing
probabilistic selection. All (unique) propose blocks that are in active rule
actions are collected, frozen in the execution state in which they were
encountered, like closures known from functional programming languages. When
all possible proposals have been selected, a statistical component decides
on the ``best'', whose closure is then executed.

\begin{figure}[h]
  \centering\small%
\begin{lstlisting}
if (!saidInSession(#Greeting(Meeting)) {
  // Wait 7 secs before taking initiative
  timeout("wait_for_greeting", 7000) {
    if (! receivedInSession(#Greeting(Meeting))
      propose("greet") {
        da = #InitialGreeting(Meeting);
        if (user.name) da.name = user.name;
        emitDA(da);
      }
  }

  if (receivedInSession(#Greeting(Meeting))
    propose("greet_back") { // We assume we know the name by now
      emitDA(#ReturnGreeting(Meeting, name={user.name});
    }
  }
}
\end{lstlisting}\vspace*{-3ex}
  \caption{\texttt{propose} and \texttt{timeout} code example}
  \label{fig:propose}
\end{figure}

\texttt{timeout}s generate the same kind of closures, but with a different
purpose. They can for example be used to trigger proactive behaviour, or to
check the state of the system after some time period, or in regular
intervals. A timeout will only be created if there is no active timeout with
the same name.

There are two variants of \texttt{timeout}: \emph{labeled timeouts}, like the
one in the previous example, run out after the specified time (unless they are
cancelled before that using the \texttt{cancelTimeout(\emph{label})} function)
and then execute their body, and \emph{behaviour timeouts}, where the first
\todo[inline]{AW: Just a mention that to my knowledge we never used behaviour
  timeouts in PAL, has it been tested? BK: Yes, but it must be described in more
  detail.}
argument is a dialogue act (see next section) instead of a label. These are
executed either when the specified time is up or the behaviour that was
triggered by the dialogue act is finished, whatever comes first.

\subsubsection{Interrupting the rule evaluation cycle}

There are multiple ways to stop rule evaluation locally (i.e. skipping the
evaluation of the current subtree) or globally (i.e. stopping the whole
evaluation cycle).
You can skip the evaluation of a specific rule you are currently in with the
statement \texttt{break label\_name;}. This will only stop the rule with the
respective label (no matter how deep the break statement is nested in it), such
that the next following rule is evaluated next.

If the evaluation is cancelled with the keyword \texttt{cancel}, all of the
following rules in the current file will be skipped (including any imported
rules). If the keyword \texttt{cancel\_all} is used, none of the following
rules, neither local nor higher in the rule tree, will be evaluated. This is
the \vonda way of deciding to not further evaluate whatever triggered the
current evaluation cycle and will mostly be used as an 'emergency exit', as the
dialogue rules should be rejecting any non-matching trigger by themselves.

To leave \texttt{propose} and \texttt{timeout} blocks, you need to use an empty
\texttt{return}, as they are only reduced representations of normal function
bodies.

\todo[inline]{There should be a complete description of the rule evaluation
  cycle, with details such as the initialization of rule class objects, etc.}

\subsubsection{Dialogue Acts}
\label{sec:caret}

A central functionality of a dialogue system is receiving and emitting dialogue
acts that result from a user utterance resp. can be transformed to natural
language by a generation component to communicate with the user. In \vonda,
the function for sending dialogue acts is called \texttt{emitDA}.

The dialogue act representation is an internal feature of \vonda. We are
currently using the DIT++ dialogue act hierarchy \citep{bunt2012iso} and
shallow frame semantics along the lines of FrameNet
\citep{ruppenhofer2016framenet} to represent dialogue acts. The natural
language understanding and generation units connected to \vonda should
therefore be able to generate or, respectively, process this representation.

\begin{figure}[htb]
  \centering\small\texttt{emitDA(\#Inform(Answer, what=\{solution\}));}
  \vspace*{-1ex}\caption{\label{fig:DA}Dialogue Act Example}
\end{figure}

Figure \ref{fig:DA} shows the dialogue act representation in \vonda, as passed
to, e.g., the \texttt{emitDA} function. \texttt{Inform}\verb|(...)| will be
recognized by \vonda as dialogue act because it has been marked with
\verb|#|. It will then create a new instance of the class DialogueAct that
contains the respective modifications. As a default, arguments of a DialogueAct
creation (i.e., character strings on the left and right of the equal sign) are
seen as and transformed to constant (string) literals, because most of the time
that is what is needed.  Surrounding a character sequence with curly brackets
(\texttt{\{\}}) marks it as an expression that should be evaluated. In fact,
arbitrary expressions are allowed inside the curly brackets.
\todo[inline]{What about automatic conversion to string?}

While this kind of shallow semantics is enough for many applications, we
already experience its shortcomings when trying to handle, for example, social
talk. One of the next improvements will be the extension of Dialogue Acts to
allow for embedded structures.


\subsubsection{Type inference and overloaded operators}
\label{sec:typeinference}

\vonda allows static type assignments and casting, but in many cases these can
be avoided. If, for example, the type of the expression on the right-hand side
of a declaration assignment is known or inferrable, it is not necessary to
explicitely state it.

You can also declare variables final.

\begin{table}[htbp]
  \centering
  \begin{small}
    \begin{lstlisting}
      if (! c.user.personality.nonchalance){ ... }
    \end{lstlisting}

    {\Large$\Downarrow$}\\

    \begin{lstlisting}
      if (!((((c != null) && (c.user != null))
             && (c.user.personality != null))
            && (c.user.personality.nonchalance != null))) {
         ...
      }
\end{lstlisting}
\end{small}

\caption{Transformation of complex boolean expressions}
\label{tab:multi-predaccess}
\end{table}
\vspace*{10pt}

%Als zeitsparendes Feature bietet rudimant insbesondere das automatische
%Vervollständingen von bool'schen Ausdrücken in den Clauses von if, while und
%for an. Da in diesem Fall bekannt ist, dass das Ergebnis boolean sein muss,
%ergänzt rudimant automatisch den Test auf die Existenz eines Objektes in der
%Clause, sollte dieses nicht Typ boolean sein. Bei Feldzugriffen testet es für
%jeden Teilzugriff, dass das erhaltene Objekt nicht null ist, um einer
%NullPointerException zur Laufzeit des generierten Codes vorzubeugen.

A time-saving (and code-readability-improving) feature of \vonda is the
automatic completion of boolean expressions in the clauses of if, while and for
statements. As it is obvious in these cases that the result of the expression
must be of type boolean, \vonda automatically fills in a test for existence if
it is not. When encountering field accesses, it makes sure that every
partial access is tested for existence (i.e., not \texttt{null}) to avoid a
\texttt{NullPointerException} in the runtime execution of the generated code.

Be aware that the expansion in the figure only occurs if the multiple field
access is used as boolean test. In the example of
\ref{tab:multi-predaccess-wrong}, if the first clause in the boolean expression
is omitted, a \texttt{NullPointerException} could still occur because the second clause does not trigger an automatic test for existence of \texttt{activity}.

\begin{table}[htbp]
  \centering
  \begin{small}
    \begin{lstlisting}
      if (activity.status && activity.status == ``foo''){ ... }
    \end{lstlisting}
  \end{small}

\caption{Transformation of complex boolean expressions}
\label{tab:multi-predaccess-wrong}
\end{table}
\vspace*{10pt}

%Die Vergleichsoperatoren in rudimant sind überladen. Neben den aus Java bekannten Anwendungen als Vergleichsoperatoren können sie auch auf Dialogakte angewendet werden. In diesen Fällen werden sie zu Subsumptionsoperatoren.

Many operators are overloaded, especially boolean operators such as
\textbf{\texttt{<=}}, which compares numeric values, but can also be used to test if an
object is of a specific class, for subclass tests between two classes, and for
subsumption of dialogue acts.

\begin{table}[htbp]
  \centering
  \begin{footnotesize}
    \begin{minipage}{0.28\textwidth}
\begin{lstlisting}
if (sa <= #Question){
  ...
}
\end{lstlisting}
    \end{minipage}\vline\hspace{1em}
    \begin{minipage}{0.5\textwidth}
\begin{lstlisting}
if (sa.isSubsumedBy(new DialogueAct("Question")) {
  ...
}
\end{lstlisting}
    \end{minipage}
  \end{footnotesize}

  \caption{Overloaded comparison operators}
  \label{tab:overloaded-comparison}
\end{table}

%\paragraph{Rudimant Typinformationen zur Verfügung stellen}
\subsubsection{External methods and fields}
\label{sec:javatypes}

As mentioned before, you can use every method or field you declare in your custom Agent implementation in your \vonda code. Their declaration in the Java-rudi interface should look like a normal Java field or method definition (cfg. figure \ref{tab:javadef}). It is possible to use generics in these definitions, although they are, for complexity reasons, restricted to be one single uppercase letter.

\begin{table}[htbp]
  %\centering
  \small
  \begin{tabular}{lp{.45\textwidth}}
    \begin{lstlisting}
    myType someVariable;
    \end{lstlisting}
    &  there is a variable of type \texttt{myType} \\

    \begin{lstlisting}
    myType someFunction(typeA a, typeB b);
    \end{lstlisting}
    &  the method someFunction takes arguments of types \texttt{typeA} and
      \texttt{typeB} and returns an object of type \texttt{myType} (void =
      void)
  \end{tabular}

  \caption{Defintions of existing Java fields and methods for \vonda}
  \label{tab:javadef}
\end{table}

There is a variety of standard Java methods called on Java classes that \vonda automatically recognizes, like e.g. the \texttt{substring} method for Strings. If you find that you need \vonda to know the return type of a new method that can or should only be called upon instances of a specific class, you can provide \vonda with knowledge about them by adding their definition to the interface as follows:


\begin{table}[htbp]
  \centering
  \small
  \begin{tabular}{lp{.45\textwidth}}

    \begin{lstlisting}
     [type]. myType Function(typeA a);
    \end{lstlisting}
    & declaration of a function that has to be called on an instance of class \texttt{type}.
  \end{tabular}

  \caption{Definition of a non-static method of Java objects}
  \label{tab:methoddef}
\end{table}

Fields of Java classes that you want to access over the instances of such a class can be defined analogously: \texttt{[type]. myType someVar}

Of course you can also use generics in these definitions. For example, the get method on lists is defined as follows in the \vonda framework:

\begin{figure}[htbp]
\centering
\small
\begin{lstlisting}
 [List<T>]. T get(int a);
\end{lstlisting}
\end{figure}
%Für Funktionen, die nicht oder nur umständlich in rudi-Code implementiert
%werden können, sollte der Nutzer eine Javaklasse \texttt{MyAgent} von der
%abstrakten Klasse \texttt{Agent} ableiten. Diese Klasse wird als
%\emph{Wrapper-Klasse} bezeichnet. Funktionen und Variablen, die in
%dieser Klasse deklariert wurden und später im rudi-Code benutzt werden sollen,
%müssen mit vollständiger Typangabe in einer Datei \texttt{MyAgent.rudi}
%deklariert werden, sodass die Typinferenz von rudimant sie korrekt
%berücksichtigen kann (zur Syntax siehe \ref{sec:rudimant-Typinferenz}).
%

%In manchen Fällen, wie etwa der Benutzung von außerhalb der rudi-Dateien
%deklarierten Funktionen und Variablen, ist es notwendig, rudimant Informationen
%über Typen zu geben. Dabei gilt folgendes Schema, nach dem Typen an beliebiger
%Stelle, für gewöhnlich jedoch in der Datei MyAgent.rudi (siehe
%\ref{rudimant-global}) deklariert werden können:

It is important to realize that all declarations in the interface are only compile information for \vonda and will not be transferred to the compiled code, whereas such declarations in the rule code itself will also appear in the compiled code.

%Wichtig ist: Diese Deklarationen werden nur für die Berechnung der Typen durch
%rudimant angegeben und werden nicht in den kompilierten Code
%übernommen. Insbesondere Zeilen wie \texttt{int i;} oder \texttt{void
%  someFunction();} entsprechen damit nicht einer gleich aussehenden Deklaration
%im Java-Code. Falls es einen Grund geben sollte, dass die Zeilen als im
%Compile-Ergebnis als dringend erforderlich betrachtet werden, hilft die in
%Kapitel \ref{rudi-verbatim} beschriebene Methode.

%\subsubsection{Überladene Vergleichsoperatoren und Tests}
%Dies überschneidet sich in großen Teilen mit dem Doku-Teil zur Typinferenz; wurde dort untergebracht

\subsubsection{Functional constructs}

%Rudimant erlaubt die Verwendung von lambda-Konstrukten. Im moment können sie
%aber nur für die Implementierung von \texttt{Predicate}
%resp. \texttt{Comparator} in den im folgenden angegebenen vier
%Funktionen. Diese Funktionen sind in \texttt{Agent} vordefiniert. Ein
%einfaches Beispiel zum Filtern von Objekten mit einer Subtyprelation wäre:

\vonda allows for using lambda constructions. At the moment, their usage is limited to the implementation of \texttt{Predicate} or \texttt{Comparator} in the functions
\todo{AW: it's just a general function now, so is it not limited anymore?} listed in table \ref{tab:lambda-functions} that are pre-defined in the Agent framework.

\begin{table}[htbp]
  \centering
  \begin{small}
	\begin{lstlisting}
	boolean some(Collection<T> coll, Function<Boolean, T> pred);
	boolean all(Collection<T> coll, Function<Boolean, T> pred);
	List<T> filter(Collection<T> coll, Function<Boolean, T> pred);
	List<T> sort(Collection<T> coll, Function<Integer, T, T> comp);
	Collection<T> map(Collection<S> coll, Function<T, S> f);
	int count(Collection<T> coll, Function<Boolean, T> pred);
	T first(Collection<T> coll, Function<Boolean, T> pred);
	\end{lstlisting}
  \end{small}

  \caption{Functions that take lambda expressions as an argument}
  \label{tab:lambda-functions}
\end{table}

For example, if you want to filter a set of RDF objects by a subtype relation, you can write:

\begin{lstlisting}
des = filter(agent.desires, (d) -> ((Desire)d) <= UrgentDesire);
\end{lstlisting}

\subsubsection{\texttt{import}}

%\texttt{import} ist ein Schlüsselwort in rudimant. Eine Zeile ''\texttt{import
%  File;}'' auf globaler Ebene, an einer beliebigen Stelle zwischenn den Regeln,
%bedeutet die Inklusion der Datei File.rudi an exakt dieser Stelle. Hiermit wird
%zum einen erreicht, dass rudimant auch diese Datei zu ausführbarem Java-Code
%kompiliert, sodass nicht alle Dateien eines Projektes separat kompiliert werden
%müssen. Zum anderen wird das vollständige Regelinventar der Datei an der
%entsprechenden Stelle im Java-Code mithilfe ihrer process-Methode aufgerufen
%und durchgearbeitet.
%
\texttt{import} is a keyword in the \vonda language. A global line like ''\texttt{import File;}'', to be placed at an arbitrary position between the rules, results in the inclusion of the file \texttt{File.rudi} at exactly this position.

This inclusion has two important effects. On the one hand, it triggers the compilation of the included file at exactly this point, such that any fields and methods known at this time will be available in the important file and it does not need to be compiled seperately. On the other hand, it has the effect that all the rules contained in the imported file will be inserted in the rule cycle at the specific position of the \texttt{import}, where in the resulting code the \texttt{process()} method of the imported file will be executed.

%\texttt{import} ermöglicht es also, das Regelinventar für ein Projekt auf
%mehrere Dateien bzw. mehrere Module aufzuteilen und diese zusammenzustecken,
%sodass ein einziger Aufruf ausreicht, um sie zu kompilieren und später auch, um
%die Auswertung der Regeln anzustoßen. Dies ist nicht nur nützlich zur
%Übersichtlichkeit und Strukturierung des Projektes, sondern fördert auch die
%Modularität, da verschiedene 'Unterbäume' der \texttt{import}-Hierarchie leicht
%ausgeklinkt oder aus anderen Projekten wiederverwendet werden können.

So the \texttt{import} functionality makes it possible to distribute the rules of a project into multiple files, respectively modules, and pin them together in such a way that they are handled as one unit when compiling or executing the compiled code. This is not only useful for clarity and structuring of a project, but also supports modularity, as different subtrees of the \texttt{import} hierarchy can easily be added, moved, taken away or re-used in different projects.

\subsubsection{Java-Code verbatim in rule files} \label{sec:rudi-verbatim}

%Rudimant verarbeitet eine Regelsprache, die mit voller Absicht nur
%eingeschränkte Java-Funktionalitäten zur Verfügung stellt. Was in rudi-Code
%nicht umzusetzen ist, sollte in Funktionen in die übergeordnete Java-Klasse
%wandern (vgl. \ref{rudimant-global}).
%
To maintain simplicity, \vonda intentionally only provides limited Java functionalities. Whatever is not feasible in \texttt{.rudi} code should be done in methods in the wrapper class.% (cfg. \ref{rudimant-global}).

%Für Fälle, in denen dies nicht genügt und vor Ort eine Funktionalität benötigt
%wird, die rudimant nicht parsen oder nicht richtig darstelllen kann, ist eine
%verbatim-Umgebung vorgesehen. Alles, was innerhalb der Zeichenfolgen \verb|/*@|
%und \verb|@*/| steht, wird behandelt wie ein mehrzeiliges Java-Kommentar, wird
%also in genau diesem Aussehen in den resultierenden Code übertragen. Dabei
%werden die klammernden Zeichenfolgen ausgelassen.
%
In cases where this is not enough and you urgently need a functionality %in a \texttt{.rudi} file
that \vonda cannot parse or represent correctly, you can use the verbatim function. Everything between \verb|/*@| and \verb|@*/| will be treated like a multi-line Java comment, meaning the content is not parsed or evaluated further. It will be transferred to the compiled code at exactly this position between statements, but without the comment symbols.

%Diese Funktionalität kann insbesondere dazu benutzt werden, am Anfang einer
%\texttt{rudi} Datei Java-Klassen zu importieren, die im kompilierten Code
%gebraucht werden.

In particular, this functionality can be used to import Java classes (i.e., with Java import statements) at the beginning of a rule file. You should however be aware that \vonda will not know these classes nor their methods and fields. It will however accept creations of instances of unknown classes, as well as your casting of results of unknown methods. If, be it for commodity or for other reasons, you want \vonda to have type information about methods called on instances on one of these classes, you can put this information into the type interface of the wrapper class (cfg. chapter \ref{sec:javatypes}).

\section{The Run-Time System}
%\subsection{Run-Time Library}
\todo{AW: This is just a different language than the rest of the documentation... reformulate?}

The run-time library contains the basic functionality for handling the rule
processing, including the proposals and timeouts, and for the on-line
inspection of the rule evaluation. There is, however, no blueprint for the main
event loop, since that depends heavily on the host application. The run-time library also
contains methods for the creation and modification of shallow semantic
structures, and especially for searching the interaction history for specific
utterances. Most of this functionality is available through the abstract
\texttt{Agent} class, which has to be extended to a concrete class for each
application.

There is functionality to talk directly to the HFC database using queries (compare section \ref{sec:hfc_usage}), in
case the object view is not sufficient or to awkward.
% The natural language
%understanding and generation components can be exchanged by implementing existing
%interfaces, and the statistical component is connected by a message exchange
%protocol. A simple generation engine based on a graph rewriting module is
%already integrated, and is used in our current system as a template based
%generator. The example application also contains a VoiceXML based
%interpretation module.

The set of your reactive \vonda rules is executed whenever there is a change in the
information state (IS). These changes are caused by incoming sensor or
application data, intents from the speech recognition, or expired timers.
%Rules are labeled if-then-else statements, with complex conditions and shortcut
%logic, as in Java or C. The compiler analyses the base terms and stores their
%values during processing for dynamic logging.
A rule can have direct effects,
like changes in the IS, or system calls. Furthermore, it can generate so-called
\emph{proposals}, which are (labeled) blocks of code in a frozen state that
will not be immediately executed, similar to closures.

All rules are repeatedly applied until a fix point is reached: No new proposals
are generated and there is no IS change in the last iteration. Then, the set of
proposals is evaluated by a statistical component, which will select the best
alternative. This component can be exchanged to make it as simple or elaborate
as necessary, taking into account arbitrary features from the data storage.

\subsection{Functionalities (methods) Provided by the Run-Time System}
%Alles was in \texttt{Agent} bereitgestellt wird. Die aktuelle Liste der
%bereitgestellten Funktionen finden sich in \texttt{rudimant} unter
%\texttt{src/main/resources/Agent.rudi}.
The following methods are declared in \texttt{src/main/resources/Agent.rudi}; their implementation is provided by Java itself or the \vonda framework.

\begin{itemize}
\item Pre-added Java methods
\begin{small}
\begin{lstlisting}
[Object]. boolean equals(Object e);
[String]. boolean startsWith(String s);
[String]. boolean endsWith(String s);
[String]. String substring(int i);
[String]. String substring(int begin, int end);
[String]. boolean isEmpty();
[String]. int length();

[List<T>]. T get(int a);
[Collection<T>]. void add(Object a);
[Collection<T>]. boolean contains(Object a);
[Collection<T>]. int size();
[Collection<T>]. boolean isEmpty();
[Map<S, T>]. boolean containsKey(S a);
[Map<S, T>]. T get(S a);
[Array<T>]. int length;

int random(int limit);
float random();
\end{lstlisting}
\end{small}

\item Short-hand conversion methods from Agent
\begin{small}
\begin{lstlisting}
int toInt(String s);
float toFloat(String s);
double toDouble(String s);
boolean toBool(String s);
String toStr(type i);  // type in (int, short, byte, float, double, boolean)
\end{lstlisting}
\end{small}

\item Other Agent methods
\begin{small}
\begin{lstlisting}
// Telling the Agent that something changed
void newData();

String getLanguage();

// Math methods
int random(int limit);
float random();

// logging methods
Logger logger;

// discarding actions and shutdown
void clearBehavioursAndProposals();
void shutdown();
\end{lstlisting}
\end{small}

\item Timeouts
\begin{small}
\begin{lstlisting}
void newTimeout(String name, int millis);
boolean isTimedOut(String name);
void removeTimeout(String name);
boolean hasActiveTimeout(String name);
// cancel and remove an active timeout, will not be executed
void cancelTimeout(String name);
\end{lstlisting}
\end{small}

\item Methods handling with dialogue acts
\begin{small}
\begin{lstlisting}
// sending of dialogue acts
DialogueAct createEmitDA(DialogueAct da);
DialogueAct emitDA(int delay, DialogueAct da);
DialogueAct emitDA(DialogueAct da);

// Access to dialogue acts of the current session
// my last outgoing resp. the last incoming dialogue act
DialogueAct myLastDA();
DialogueAct lastDA();

// Did I say something like ta in this session (subsumption)? If so, how many
// utterances back was it? (otherwise, -1 is returned)
int saidInSession(DialogueAct da);
// like saidInSession, only for incoming dialogue acts
int receivedInSession(DialogueAct da);

boolean waitingForResponse();
void lastDAprocessed();
DialogueAct addLastDA(DialogueAct newDA);
[DialogueAct]. void setProposition(String prop);
\end{lstlisting}
\end{small}

\item Methods using lambda expressions
\begin{small}
\begin{lstlisting}
boolean some(Collection<T> coll, Function<Boolean, T> pred);
boolean all(Collection<T> coll, Function<Boolean, T> pred);
List<T> filter(Collection<T> coll, Function<Boolean, T> pred);
List<T> sort(Collection<T> coll, Function<Integer, T, T> c);
Collection<T> map(Collection<S> coll, Function<T, S> f);
int count(Collection<T> coll, Function<Boolean, T> pred);
T first(Collection<T> coll, Function<Boolean, T> pred);
T random(Collection<T> coll);
\end{lstlisting}
\end{small}

\item Methods callable on Rdf objects
\begin{small}
\begin{lstlisting}
Rdf toRdf(String uri);
[Rdf]. String getURI();
[Rdf]. boolean has(String predicate);
[Rdf]. long getLastChange(boolean asSubject, boolean asObject);
\end{lstlisting}
\end{small}

\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "userguide"
%%% End:
