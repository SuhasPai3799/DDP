assess_performance:
if (! (myLastDA <= #Inform(AssessingPerformance))
    && ! (myLastDA <= #Goodbye(Meeting))  // wenn subtype /supertyp funktioniert
    // && ! (myLastDA <= #InitialGoodbye(Meeting"))
    ) {
  emitDA(#Breaking(Playing, Reason=reason));
  logger.info("AssessingPerformance");
  propose("AssessUserPerformance") {
    //TODO get actual total and correct values
    //TODO look at information from previous games
    emitDA(#Inform(AssessingPerformance, theme="Answer",
                   agent="user", total="5", correct="5"));
  }
  propose("AssessRobotPerformance") {
    emitDA(#Inform(AssessingPerformance, theme="Answer", agent="robot",
                   total="5", correct="0"));
  }
  endQuiz(q, reason);
}

end_quiz:
if (isMyLastDA(#Inform(AssessingPerformance))) {
  propose("endQuiz") {
    logger.info("we are in endQuiz");
    if (myLastDA <= #Inform(AssessingPerformance)) {
      String dialogueAct = firstEncounter() ? "InitialGoodbye" : "ReturnGoodbye";
      if (user.isEqual(CHILD_LOCATION, "Home")) {
        dialogueAct = "ReturnGoodbye";
      }
    // TODO: Übergeben von #ReturnGoodbye als String wird nicht funktionieren,
    // gibt es hier eine andere Möglichkeit als das Ganze in drei Emits
    // aufzuteilen?
      DialogueAct close = #_dialogueAct(Meeting, theme="Quiz");
      stopQuiz(q, NaoAgent.this);
      /*@ activity = newActivity(new Closing(NaoAgent.this));
      closeSession((Closing) activity, close); @*/
    }
  }
}

// BK TODO: Mal wieder so ein Makro / Methode ...
user_reads_question:
//! Casten: bisher kann rudimant das nicht
// BK: braucht es auch nicht, das wird ein RdfProxy objekt, das sieht dann
// sowieso ganz anders aus. Nur wie ist das mit dem Typ, siehe naechste
// Anmerkung
if(true){
/*@   Quiz quiz = (Quiz) activity; @*/
// BK TODO: hier stellt sich eher die Frage: Wie kann man RdfProxies um
// eigene Methoden erweitern? Subklassieren von RdfProxy???
    Turn currentTurn = quiz.getCurrentTurn();
    if (currentTurn != null) {
      QuizQuestion q = getQuizQuestion(currentTurn.QuestionId);
      if (q != null) {
        // Generate next question / answers
        // BK: evtl markieren mit ^ zum "einspleissen"?
        addLastDA(#Inform(Asking, ^getQuestionArgs(q, currentTurn)));
        addLastDA(#Inform(Answering, ^getAnswerArgs(q)));
      }
    }
}
// BK: siehe oben.
robot_answers:
//! wieder Casting // BK: siehe oben.
if (true) {
    Quiz quiz = activity;
//??    emitDA(#Inform(Answer, id=^Integer.toString(number + 1),
//??                   ^("string"+Integer.toString(number + 1))=^answerString));
    quiz.status= "answer_given";
    Turn current = quiz.getCurrentTurn();
/*@    current.put("AnswerCorrect", new Boolean(correct)); @*/
    lastDAprocessed();
}
//! newActivity: auch hier: verschieben?
// BK: vielleicht ein Makro

process_rules:
if (user == null) {
  //! rudimant kann return, aber wahrscheinlich ist das hier trotzdem
  //! Quatsch!
  // BK: nicht unbedingt. Das koennte fuer rudimant so was sein wie fuer
  // Prolog das Cut. Nach dem Motto: wenn das schon nicht, dann ist hier
  // Schluss
  return;
}
if (! currentSession) {
/*@      currentSession = new Session(this); @*/
  currentSession.child = user;
  if (! activity) {
    if (user.location != "Hospital") {
/*@          newActivity(new Introduction(this)); @*/
  } else {
    initQuiz();
  }
 }
}


//BK: wird viel mehr.
process_timeouts:
if (isTimedout("start")) {
  removeTimeout("start");
}

init_quiz:
/*@    Quiz quiz = newActivity(new Quiz(this)); @*/
if (quiz.status == "none" || !quiz.status) {
  quiz.player = user.id;
  quiz.status = started;
/*@      quiz.begins = new Date(); @*/

  //Max: put tabletorientation to child
  quiz.tabletorientation = "child";
}

process_incoming_speechacts:
    // TODO: ALL THESE RULES DEFINITELY LOOK AT AN !!UNPROCESSED!!
    // INCOMING DIALOGUE ACT

if (lastDA <= #Greeting(Meeting)) {
  // || lastDA <= #ReturnGreeting(Meeting) // BK: wieder subclass
  if (activity <= Introduction) {
    intro = activity;
    intro.greetingreceived = lastDA;
  } else {
    logger.warn("greeting while not doing intro.");
  }
  lastDAprocessed();
}

robot_starts_quiz:
if ((lastDA <= #AcceptRequest(Playing) || lastDA <= #Confirm(Playing))
    && !(activity <= Quiz)) {
  initQuiz();
  lastDAprocessed();
}

robot_accepts_game_reject:
if ((lastDA <= #RejectRequest(Playing) || lastDA <= #Disconfirm(Playing))
    && activity && !(activity <= Quiz) && !(activity <= Closing)) {
  // OK, maybe next time
  emitDA(#Disconfirm(Playing));
/*@      newActivity(new Closing(this)); @*/
  lastDAprocessed();
}

robot_accepts_role:
if (lastDA <= #Request(AssigningRole)) { // BK subclass
  //  || lastDA <= #AcceptRequest(AssigningRole))
  //        || lastDA <= #RejectRequest(AssigningRole))) {
  if (!activity || !(activity <= Quiz))
    { // TODO: clarification dialogue??
      return;
    }
  String theme = lastDA.theme;
  String agent = lastDA.agent;
  if (null == theme) {
    agent = "user";
  } else { // turn agent around
    if (lastDA <= #RejectRequest(AssigningRole)) {
      agent = "user".equals(agent) ? "robot" : "user";
    }
  }
  String currentAgent = mapAgentToUri(agent);

  // TODO check if theme matches current activity (e.g. quiz game)
  Quiz quiz = activity;
  // BK: fishy, RdfProxy problem
  Turn t = quiz.newTurn();
  // BK: fishy, RdfProxy problem
  /*@ t.setAsker(currentAgent,
          (currentAgent.equals(I_ROBOT) ? (String) user.get("id") : I_ROBOT)); @*/
  // THIS IS ONLY THE COMMUNICATION WITH THE QUIZ LOGIC
  // Todo: see above, not yet implemented, always accept
  if (true) {
    emitDA(#Accept(AssigningRole, theme=^theme, agent=^agent));
    emitDA(#Inform(Instructing, theme=^theme,
                   agent=^agent, purpose="Asking"));
    startQuiz(quiz, this);
    if (quiz.status == "started") {
      quiz.status = "running";
    }
  }
  lastDAprocessed();
}

// ! hier kommt: waitingForResponse; hat returns

// The child has read question and answers, now the robot has to give an
// answer
robot_gives_answer:
if (lastDA <= #Inform(Answering)) {
  // BK: solche timeouts fliegen raus.
  timeout("RobotSeeksAnswer", 600) {
    //Quiz quiz = (Quiz) activity;
    quiz = activity;
    Turn currentTurn = quiz.getCurrentTurn();
    // siehe oben
    /*@ QuizQuestion q = (QuizQuestion) currentTurn.get("QuestionId"); @*/
    int correct = q.getWhichCorrect();
    // Answers were read by child, give an answer
    emitDA(#Stalling(Answering));
    propose("give_correct_answer") {
      robotAnswers(q.getAnswers().get(correct), correct, true);
      // maybe invalidate the lastDAs, also below
    }

    propose("give_wrong_answer") {
      int number = 0;
      while ((number = random.nextInt(q.getAnswersSize())) == correct) {
      }
      robotAnswers(q.getAnswers().get(number), number, false);
    }
    lastDAprocessed();
  }
}
