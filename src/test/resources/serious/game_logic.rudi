/* old, replaced by assessQuizSession
assess_performance:
if (! (myLastDA <= #Inform(AssessingPerformance))
    && ! (myLastDA <= #Goodbye(Meeting))  // wenn subtype /supertyp funktioniert
    // && ! (myLastDA <= #InitialGoodbye(Meeting"))
    ) {
  emitDA(#Breaking(Playing, Reason=reason));
  logger.info("AssessingPerformance");
  propose("AssessUserPerformance") {
    //TODO get actual total and correct values
    //TODO look at information from previous games
    emitDA(#Inform(AssessingPerformance, theme="Answer",
                   agent="user", total="5", correct="5"));
  }
  propose("AssessRobotPerformance") {
    emitDA(#Inform(AssessingPerformance, theme="Answer", agent="robot",
                   total="5", correct="0"));
  }
  endQuiz(q, reason);
} */

assess_quiz_session:
  if(whose) {
// Get the amount of questions answered, and the number of correct answers
      int[] results = quiz.getAssessment(I_ROBOT);
      int index = whose.equals("robot") ? 0 : 2;
      String i;
      /*@ String i = Integer.toString(results[index + 1]); @*/
      emitDA(#Inform("AssessingPerformance", "theme", "Answer",
          "agent", whose, "total", Integer.toString(results[index]),
          "correct", i));
    }
    quiz.status = "wait_for_ending";

end_quiz:
  if (!isMyLastDA(#Inform("AssessingPerformance"))
        && !isMyLastDA(#ReturnGoodbye("Meeting"))
        && !isMyLastDA(#InitialGoodbye("Meeting"))) {
      emitDA(#Breaking("Playing", "Reason", reason));

      quiz.status = "wait_for_assessment";
  }

// BK TODO: Mal wieder so ein Makro / Methode ...
user_reads_question:
//! Casten: bisher kann rudimant das nicht
// BK: braucht es auch nicht, das wird ein RdfProxy objekt, das sieht dann
// sowieso ganz anders aus. Nur wie ist das mit dem Typ, siehe naechste
// Anmerkung
if(true){
/*@   Quiz quiz = (Quiz) activity; @*/
// BK TODO: hier stellt sich eher die Frage: Wie kann man RdfProxies um
// eigene Methoden erweitern? Subklassieren von RdfProxy???
    Turn currentTurn = quiz.currentTurn;
    if (currentTurn != null) {
      QuizQuestion q = getQuizQuestion(currentTurn.QuestionId);
      if (q != null) {
        // Generate next question / answers
        // BK: evtl markieren mit ^ zum "einspleissen"?
        addLastDA(#Inform(Asking, ^getQuestionArgs(q, currentTurn)));
        addLastDA(#Inform(Answering, ^getAnswerArgs(q)));
      }
    }
}

// BK: siehe oben.
robot_answers:
//! wieder Casting // BK: siehe oben.
if (true) {
  if (Math.random() > 0.5) {
      // Robot thinks about the anser
      emitDA(#Stalling("Answering"));
    }
    Quiz quiz = activity;
//??    emitDA(#Inform(Answer, id=^Integer.toString(number + 1),
//??                   ^("string"+Integer.toString(number + 1))=^answerString));
    quiz.status= "answer_given";
    Turn current = quiz.currentTurn;
/*@    current.put("AnswerCorrect", new Boolean(correct)); @*/
    lastDAprocessed();
}

//! newActivity: auch hier: verschieben?
// BK: vielleicht ein Makro

process_rules:
if (true){
if (user == null) {
  //! rudimant kann return, aber wahrscheinlich ist das hier trotzdem
  //! Quatsch!
  // BK: nicht unbedingt. Das koennte fuer rudimant so was sein wie fuer
  // Prolog das Cut. Nach dem Motto: wenn das schon nicht, dann ist hier
  // Schluss
  return;
}
if (! currentSession) {
/*@      currentSession = new Session(this); @*/
  currentSession.child = user;
  if (! activity) {
/*@          newActivity(new Introduction(this)); @*/
/*
    if ("Hospital".equals(user.location)) {
  } else {
       // This has to be done as reaction to a QuizCommand coming from the
       // MyPalHomeApp
    initQuiz();
  } */
 }
}
}

//BK: wird viel mehr.
process_timeouts:
if (isTimedout("start")) {
  removeTimeout("start");
}

Quiz quiz;
init_quiz:
/*@    Quiz quiz = newActivity(new Quiz(this)); @*/
if (quiz.status == "none" || !quiz.status) {
  quiz.player = user.id;
  quiz.status = started;
/*@      quiz.begins = new Date(); @*/

  //Max: put tabletorientation to child
  quiz.tabletorientation = "child";
}

process_incoming_speechacts:
    // TODO: ALL THESE RULES DEFINITELY LOOK AT AN !!UNPROCESSED!!
    // INCOMING DIALOGUE ACT

if (lastDA <= #Greeting(Meeting)) {
  // || lastDA <= #ReturnGreeting(Meeting) // BK: wieder subclass
  if (activity <= Introduction) {
    intro = activity;
    intro.greetingreceived = lastDA;
  } else {
    logger.warn("greeting while not doing intro.");
  }
  lastDAprocessed();
}

robot_starts_quiz:
if ((lastDA <= #AcceptRequest(Playing) || lastDA <= #Confirm(Playing))
    && !(activity <= Quiz)) {
  initQuiz();
  lastDAprocessed();
}

robot_accepts_game_reject:
if ((lastDA <= #RejectRequest(Playing) || lastDA <= #Disconfirm(Playing))
    && activity && !(activity <= Quiz) && !(activity <= Closing)) {
  // OK, maybe next time
  emitDA(#Disconfirm(Playing));
/*@      newActivity(new Closing(this)); @*/
  lastDAprocessed();
}

robot_accepts_role:
if (lastDA <= #Request(AssigningRole) // BK subclass
    || lastDA <= #AcceptRequest(AssigningRole)
        || lastDA <= #RejectRequest(AssigningRole)) {
  if (!activity || !(activity <= Quiz))
    { // TODO: clarification dialogue??
      return;
    }
  String theme = lastDA.theme;
  String agent = lastDA.agent;
  if (null == agent) {
    agent = "user";
  } else { // turn agent around
    if (lastDA <= #RejectRequest(AssigningRole)) {
      agent = "user".equals(agent) ? "robot" : "user";
    }
  }
  String currentAgent = mapAgentToUri(agent);

  // TODO check if theme matches current activity (e.g. quiz game)
  Quiz quiz = activity;
  // BK: fishy, RdfProxy problem
  /*@ Turn t = quiz.newTurn(); @*/
  Turn t;
  // BK: fishy, RdfProxy problem
  /*@ t.setAsker(currentAgent,
          (currentAgent.equals(I_ROBOT) ? (String) user.get("id") : I_ROBOT)); @*/
  // THIS IS ONLY THE COMMUNICATION WITH THE QUIZ LOGIC
  // Todo: see above, not yet implemented, always accept
  if (true) { // accept role
    emitDA(#Accept(AssigningRole, theme=^theme, agent=^agent));
        /* This is more or less a duplication of the above
    emitDA(#Inform(Instructing, theme=^theme,
                   agent=^agent, purpose="Asking")); */
    startQuiz(quiz, this);
    if ("started".equals(quiz.status)) {
      quiz.status = "running";
    }
  }
  lastDAprocessed();
}

// ! hier kommt: waitingForResponse; hat returns

// The child has read question and answers, now the robot has to give an
// answer
robot_gives_answer:
if (lastDA <= #Inform(Answering)) {
  // BK: solche timeouts fliegen raus.
  // timeout("RobotSeeksAnswer", 600) {
    //Quiz quiz = (Quiz) activity;
    quiz = activity;
    Turn currentTurn = quiz.currentTurn;
    // siehe oben
    /*@ QuizQuestion q = (QuizQuestion) currentTurn.get("QuestionId"); @*/
    int correct = q.getWhichCorrect();
    // Answers were read by child, give an answer
    /// old emitDA(#Stalling(Answering));
    propose("give_correct_answer") {
   /*@   robotAnswers(q.getAnswers().get(correct), correct, true); @*/
      // maybe invalidate the lastDAs, also below
    }
    propose("give_wrong_answer") {
      int number = 0;
      while ((number = random.nextInt(q.getAnswersSize())) == correct) {
      }
   /*@      robotAnswers(q.getAnswers().get(number), number, false); @*/
    }
    lastDAprocessed();
//  }
}
