

process_rules_quiz:
    if(true){
    if (activity == null || ! (activity <= Quiz)) //! wie letzte Regel: instanceOf
      return;

    //Quiz quiz = (Quiz) activity;
    Quiz quiz = activity;
    logger.info("Quiz status: {}, Asker: {}", quiz.get(QUIZ_STATUS),
        quiz.currentAsker);

    // if (quiz.isEqual(QUIZ_STATUS, "started")) {
    if ("started".equals(quiz.status)) {
      logger.info("Quiz started {}", System.currentTimeMillis());
      int lastInfo = lastOccurenceOfMyDA(#Inform(Instructing, theme=Quiz));
      if (! user.hasPlayedQuiz && lastInfo < 0) {
        propose("inform_gamerules") {
            emitDA(#Inform("Instructing", "theme", "Quiz"));
          }
      }

      if ((user.hasPlayedQuiz
           || lastOccurenceOfMyDA(#Inform("Instructing", "theme", "Quiz")) >= 0)
          && quiz.currentAsker == null
          && ! waitingForResponse()
          ) {
        propose("ask_for_user_starts") {
            emitDA(#Request("AssigningRole", "theme", "Quiz", "agent", "user"));
            // TODO: ADD: RE-ASK WHEN NO REACTION: MAYBE DO IT MORE GENERAL
            // timeouts.newTimeout("ask_for_role", 10000);
          }
        propose("ask_for_robot_starts") {
            emitDA(#Request("AssigningRole", "theme", "Quiz", "agent", "robot"));
            // TODO: ADD: RE-ASK WHEN NO REACTION: MAYBE DO IT MORE GENERAL
            // timeouts.newTimeout("ask_for_role", 10000);
          }
      }

    /* if (quiz.oneOf(QUIZ_STATUS,
        "running", "wait_for_question", "wait_for_question_read",
        "wait_for_tablet", "wait_for_answer", "answer_given",
        "wait_for_continue")) { */
    /* old  possibleStates = {"running", "wait_for_question", "wait_for_question_read",
        "wait_for_tablet", "wait_for_answer", "answer_given",
        "wait_for_continue"};
    if (possibleStates.contains(quiz.status)) {
      processRulesQuizRunning(quiz);
    } */
   
    if ("wait_for_ending".equals(quiz.status)
        || "ended_by_user".equals(quiz.status)) {
      logger.info("we are in endQuiz");
      propose("endQuiz") {
          String dialogueAct = firstEncounter() ? "InitialGoodbye" : "ReturnGoodbye";
          if (childAtHome()) {
            // TODO this is not really necessary/right, since if it is the first
            // time, the robot should use the initial goodbye, which will never
            // occur in our setup.
            dialogueAct = "ReturnGoodbye";
          }
          DialogueAct close = emitDA(#dialogueAct("Meeting", "theme", "Quiz"));
          if ("wait_for_ending".equals(quiz.status)) {
            // otherwise this comes from the user / app
            stopQuiz(quiz, NaoAgent.this);
          }
          /*@ newActivity(new Closing(NaoAgent.this)); @*/
          /*@ closeSession((Closing) activity, close); @*/
        }
      }
    }

    // TAKE CARE THAT YOU PROPERLY UPDATE THIS METHOD WHEN ADDING A NEW QUIZ
    // STATUS
    // This should comprise all rules that need a valid asker / turn
    if (quiz.running) {
      processRulesQuizRunning(quiz);
    }
  }

process_rules_quiz_running:
    // Question asked already??
if (true){

    // TODO: THIS IS ONLY A TEMPORARY SOLUTION TO FIX ISSUE dialogmanager:#10
    if ("running".equals(quiz.status)) {
      boolean askerRobot = quiz.currentAsker.equals(I_ROBOT);
      if (askerRobot && !"robot".equals(quiz.tabletorientation)) {
        if (childAtHome()) {
          quiz.tabletorientation = "robot";
          logger.info("Turn tablet to robot in home version here.");
          userReadsQuestion();
        } else {
          // rudi cant do that   newTimeout("TurnTabletToRobot", 10000, new Proposal() {
            propose("TurnTabletToRobot"){
              if (!(activity <= Quiz)) {
                return;
              }
              /*@ Quiz q = (Quiz) activity; @*/
              Quiz q;
              boolean askerRobotNow = q.currentAsker.equals(I_ROBOT);
              if ("wait_for_question_read".equals(quiz.status)
                  && !askerRobotNow
                  && "child".equals(quiz.tabletorientation)) {
                // Change the tablet orientation automatically in the home version.
                propose("request_turn_tablet") {
                    emitDA(#Request("Turning", "theme", "Tablet"));
                    // maybe introduce a timeout to ask again
                  }
                }
              }
            }
        }
      }

    /* if (! quiz.currentTurn.has(TURN_QUESTIONID)
        && ! quiz.isEqual(QUIZ_STATUS, "wait_for_question")
        && ! quiz.isEqual(QUIZ_STATUS, "wait_for_continue")) { */
      if (! quiz.currentTurn.turnQuestionId
        && ! "wait_for_question".equals(quiz.status)
        && ! "wait_for_continue".equals(quiz.status)) {

      logger.info("REQUEST NEW QUESTION, THE CURRENT ASKER IS {}, THE CURRENT RESPONDER IS {}",
          quiz.currentAsker,
          quiz.currentAsker.equals(I_ROBOT) ? user.id : I_ROBOT);

      // retrieve question/answer from quizdb
      requestNextQuestion(this);
      //quiz.put(QUIZ_STATUS, "wait_for_question");
      quiz.status = "wait_for_question";
      // TODO: ADD A CONTINOUS TIMER THAT RETRIES SEVERAL TIMES IF NO QUESTION
      // COMES, AND AFTER TWO RETRIES COMES BACK TO THE USER AND TELLS HER/HIM
      // THERE ARE TECHNICAL PROBLEMS

    } else {
     if ("wait_for_tablet".equals(quiz.status)) {
      // CurrentAsker has the correct value now, a question arrived
      // if (! quiz.isEqual(QUIZ_TABLETORIENTATION,
      //     quiz.currentAsker.equals(I_ROBOT) ? "robot" : "child" )) {
       if(! quiz.currentAsker.equals(quiz.tabletorientation)) {
        if (! isMyLastDA(#Request("Turning"))) {
          propose("request_turn_tablet") {
              emitDA(#Request("Turning", "theme", "Tablet"));
              // maybe introduce a timeout to ask again
            }
        }
      } else {
        // tablet orientation is OK, question will be posed by robot or child
        if (quiz.currentAsker.equals(I_ROBOT)) {
          // The robot reads the question and answers
          propose("give_next_question") {
              Turn current = quiz.currentTurn;
              /*@ QuizQuestion q = (QuizQuestion) current.get(Turn.TURN_QUESTIONID); @*/
              QuizQuestion q;
              String[] answerArgs;
              /*@ String[] answerArgs = new String[2 * q.getAnswers().size()]; @*/
              int i = 0;
              for (String answer : q.getAnswers()) {
              /*@  answerArgs[i] = "string" + (1 + i/2); @*/
              /*@  answerArgs[i+1] = answer; @*/
                i += 2;
              }
              // Generate next question / answers
              // This needs to know the number of questions that was asked
              // by this agent, done by infoState
              emitDA(#Inform("Asking",
                  "string", q.getQuestionText(),
                  "id", Integer.toString(1 + getNumberOfQuestionsCurrentAsker())));
              emitDA(#Inform("Answering", answerArgs));

              // turn tablet
              emitDA(#Inform("Turning", "theme", "Tablet", "manner", "silent"));

              // change status
              quiz.status = "wait_for_answer";
            }
        } else {
          // The user is the asker, wait for the user to finish reading
          // the question and answers, if we have a real robot
          quiz.status = "wait_for_question_read";
        }
      }
    } else {
     if ("answer_given".equals(quiz.status)
            && !isMyLastDA(#Request("BeingCorrect", "agent", "user", "theme", "Quiz"))) {
      Turn current = quiz.currentTurn;
        /*@ String responder = ((String) current.get(TURN_RESPONDER)).equals(I_ROBOT)
               ? "robot" : "user"; @*/
        String responder;
        if (responder.equals("robot")) {
         // TODO listen for the user to tell the robot whether his answer was 
         // right or wrong.
//         newTimeout("UserTellsRobotRightOrWrong", 4000);
         propose("request_beingcorrect"){
             emitDA(#Request("BeingCorrect", "agent", "user", "theme", "Quiz"));
           }
        } else {
         quiz.status = "feedback_given";
        }
      } 
}
     if ("feedback_given".equals(quiz.status)) {

      Turn current = quiz.currentTurn;

//! Wieder das Problem: sollte rudimant Casten vertragen? WÃ¼rde wahrscheinlich Probleme im entstehenden Javacode vorbeugen, wenn rudimant nicht zu Object greifen muss weil es durch das Casten ja Hinweise kriegt
      /*@ Boolean correct = (Boolean) current.get(TURN_ANSWERCORRECT); @*/
      boolean correct;
      /*@ String responder = ((String) current.get(TURN_RESPONDER)).equals
              String[] answerArgs(I_ROBOT)
          ? "robot" : "user"; @*/
      String responder;
      String proposal = "feedback_" + (correct ? "correct_" : "wrong_")
          + responder;
      // give feedback to my or the user's success
      propose(proposal) {
          if (responder.equals("robot")) {
//! Hier wieder das Problem: String concatenation geht nicht mehr wenn wir #Confirm schreiben wollen
//! oder: das als archaische Herangehensweise erlauben? Dazu muss rudimant emitDA erkennen und reagieren, je nachdem, ob da " oder # kommt
            emitDA("Allo" + (correct ? "Positive" : "Negative"),
                "BeingSuccessful", "theme", "Quiz");
          } else {
            emitDA((correct ? "Confirm" : "Disconfirm"), "BeingCorrect",
                "theme", "Quiz", "agent", "user");
            quiz.status = "wait_for_continue";
            if (!correct) {
              /*@ QuizQuestion q = (QuizQuestion) current.get(Turn.TURN_QUESTIONID); @*/
              QuizQuestion q;
              String solutionNo = Integer.toString(q.getWhichCorrect() + 1);
              emitDA(#Inform("GivingSolution",
                      "string" + solutionNo, q.answers.get(q.getWhichCorrect()),
                      "id", solutionNo));
            }
            quiz.status = "wait_for_continue";
          }
        }

    }
   }
      // since currently one proposal is always taken, we just propose also
      // a continue_quiz
      // TODO: adapt once that changes
      logger.info("TODO this quiz_status");
      quiz.status = "wait_for_something";

    if ("wait_for_continue".equals(quiz.status)) {
      // TODO FIX THIS, ONLY FOR TESTING !!!!!
      if (true || quiz.getNumberOfTurns() < 5) {
      propose("continue_quiz") {
          Turn last = quiz.currentTurn;
          Turn t = quiz.newTurn();
          // Switch roles after each turn
          /*@ t.setAsker((String)last.get(TURN_RESPONDER),
              (String)last.get(TURN_ASKER)); @*/
          quiz.status = "running";
        }
      }

      propose("quiz_game_ends_max_time") {
          //old   emitDA(#provide("playStop", "Reason", "technical"));
          //old   /*@ activity = newActivity(new Closing(NaoAgent.this)); @*/
          endQuiz(quiz, technical);
        }

      propose("quiz_game_ends_max_rounds") {
          //old   emitDA(#provide("playStop", "Reason", "time"));
          //old   /*@ activity = new Closing(NaoAgent.this); @*/
          endQuiz(quiz, time);
        }
    }

    if ("wait_for_assessment".equals(quiz.status)) {

      logger.info("AssessingPerformance");

      propose("AssessUserPerformance") {
        // seems strange, but is correct, this must be "user" and vice versa
          assessQuizSession(quiz, "robot");
        }
      propose("AssessRobotPerformance") {
          assessQuizSession(quiz, "user");
        }
      propose("NoAssessment") {
          assessQuizSession(quiz, null);
        }
    }

    if (childAtHome()
        && isMyLastDA(#Inform("Turning", "theme", "Tablet", "sender", I_ROBOT))
        && ! "child".equals(quiz.tabletorientation)) {
      quiz.tabletorientation = "child";
      logger.info("Turn tablet to child here in Home version.");
    }
}


process_rules_closing:
  if (true){
    if (! (activity <= Closing)) return;
    Closing closing;
    /*@ Closing closing = (Closing)activity; @*/

    if (! closing.has(CLOSING_PROPOSED)) {
      closing.put(CLOSING_PROPOSED, "null");
      propose("closing"){
         logger.info("When does this happen?");

          String dialogueAct = firstEncounter() ? "InitialGoodbye" : "ReturnGoodbye";
          logger.info("emitDA ReturnGoodby in method processRulesClosing()");

          if (! childAtHome()) {
            NaoAgent.this.closeSession(closing, emitDA(dialogueAct, "Meeting"));
          } else {
            NaoAgent.this.closeSession(closing, emitDA(#ReturnGoodbye("Meeting")));
          }
        }
      }
      /*old   propose("closing") {
          closing.put(CLOSING_PROPOSED, emitDA(#salutation("closing")));
          user.addToList(CHILD_SESSIONS, currentSession);
          reset();
        } */
    }
  
