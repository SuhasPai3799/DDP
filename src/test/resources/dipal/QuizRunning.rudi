//String stat = activity.status; // see if the one below does work
process_rules_quiz_running:
if (! quiz.status.startsWith("run"))
  return;

just_started:
if (quiz.status == "run_started"
    && quiz.tabletOrientation != getCurrentAsker()) {
  if (childAtHome()) {
    quiz.tabletOrientation = getCurrentAsker();
    logger.info("Turn tablet to asker in home version here.");
    quiz.status = "run_wait_for_tablet";
  } else {
    newTimeout("TurnTabletToAsker", 10000);
  }
}

tablet_to_asker:
if (isTimedOut("TurnTabletToAsker")) {
  removeTimeout("TurnTabletToAsker");
  if (quiz.tabletOrientation != getCurrentAsker()) {
    propose("request_turn_tablet") {
      emitDA(#Request(Turning, theme=Tablet));
    }
  }
}

tablet_to_responder:
if (isTimedOut("TurnTabletToResponder")) {
  removeTimeout("TurnTabletToResponder");
  if (quiz.tabletOrientation == getCurrentAsker()) {
    // Change the tablet orientation automatically in the home version.
    if (childAtHome()) {
      if (getCurrentResponder() == I_ROBOT) {
        // simulate turning the tablet to the robot in home version
        quiz.tabletOrientation = getCurrentResponder();
        logger.info("Turn tablet to robot in home version");
        userReadsQuestion();
      }
    } else {
      propose("request_turn_tablet") {
        emitDA(#Request(Turning, theme=Tablet));
      }
    }
  }
}

question_asked:
if (! getCurrentTurn(quiz).questionId
    && quiz.status != "run_wait_for_question"
    && quiz.status != "run_wait_for_continue") {
  asker = getCurrentAsker();
  responder = (asker == I_ROBOT) ? user : I_ROBOT;
  logger.info("REQUEST NEW QUESTION, THE CURRENT ASKER IS {}, THE CURRENT RESPONDER IS {}",
              asker, responder);
  getHub().requestNextQuestion(asker);
  quiz.status = "run_wait_for_question";
}

asker_tablet_wait:
if (quiz.status == "run_wait_for_tablet"
    && quiz.tabletOrientation == getCurrentAsker()) {
  // tablet orientation is OK, question will be posed by robot or child
  if (getCurrentAsker() == I_ROBOT) {
    propose("give_next_question") {
      turn = getCurrentTurn(quiz);
      sendQuestionDA(turn);
      sendAnswersDA(turn);

      turnTabletDA = #Inform(Turning, theme=Tablet, manner=silent);
      if (childAtHome()) {
        addToMyDA(turnTabletDA); // pretend emitting the DA
      } else {
        emitDA(turnTabletDA);
        newTimeout("TurnTabletToResponder", 20000);
      }
      quiz.status = "run_wait_for_answer";
    }
  } else {
    // current asker is user

    // wait for the user to finish reading the question and answers,
    // if we have a real robot
    if (quiz.status != "run_wait_for_question_read") {
      quiz.status = "run_wait_for_question_read";
      newTimeout("TurnTabletToResponder", 10000);
    }
  }
}

answer_given:
if (quiz.status == "run_answer_given") {
  turn = getCurrentTurn(quiz);

  boolean correct = turn.correct;
  String responder = turn.responder == I_ROBOT ? "robot" : "user";

  propose("run_feedback_" + (correct ? "correct_" : "wrong_")
          + responder) {
    if (responder == "robot") {
      String daType = "Allo" + (correct ? "Positive" : "Negative");
      emitDA(#^daType(BeingCorrect, theme=Quiz, agent=user));
    } else {
      String daType = correct ? "Confirm" : "Disconfirm";
      emitDA(#^daType(BeingCorrect, theme=Quiz, agent=robot));
      robotGivesSolution(correct, turn);
    }
    quiz.status = "run_wait_for_continue";
  }
}

wait_for_continue:
if (quiz.status == "run_wait_for_continue") {
  // TODO FIX THIS, ONLY FOR TESTING !!!!!
  if (true || getNumberOfTurns(quiz) < 5) {
    propose("continue_quiz") {
      QuizHistory turn = getCurrentTurn(quiz);
      QuizHistory newTurn = new QuizHistory;
      // Switch roles after each turn
      newTurn.asker = turn.responder;
      newTurn.responder = turn.asker;
      quiz.hasHistory.add(newTurn);
      quiz.status = "running";
    }
  }

  propose("quiz_game_ends_max_time") {
    endQuiz("technical");
  }

  propose("quiz_game_ends_max_rounds") {
    endQuiz("time");
  }
}
